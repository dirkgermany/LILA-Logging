## Funktionalität
* Reconnect für Client und Server

## Regeln für Alarmierung
* Eventuell Regel-Tabelle; so kann ein neuer Server, der für eine Gruppe bestimmt ist, die Regeln auslesen

```sql
-- Archiv für die Regel-Definitionen (JSON)
CREATE TABLE lila_rules_library (
    rule_version    NUMBER(10) PRIMARY KEY,
    rule_json       BLOB, -- BLOB oder JSON (ab 21c/23ai), um große Regelwerke zu speichern
    created_at      TIMESTAMP DEFAULT SYSTIMESTAMP,
    description     VARCHAR2(200),
    CONSTRAINT lila_rules_json_chk CHECK (rule_json IS JSON)
);

-- Die Zentrale Server-Registry
CREATE TABLE lila_registry (
    server_name          VARCHAR2(128) PRIMARY KEY, -- Der eindeutige Name (gleichzeitig Pipe-Name)
    server_group         VARCHAR2(128) NOT NULL,    -- Gruppierung für Load-Balancing durch Clients
    is_active            NUMBER(1) DEFAULT 0,       -- 1 = Server läuft, 0 = Inaktiv
    pipe_load            NUMBER(10) DEFAULT 0,      -- Aktueller Füllstand der Pipe (für Client-Wahl)
    rule_version_target  NUMBER(10),                -- Soll-Version (vom Admin gesetzt)
    rule_version_usage   NUMBER(10),                -- Ist-Version (vom Server aktuell genutzt)
    last_heartbeat       TIMESTAMP DEFAULT SYSTIMESTAMP, -- Letzte Aktivität des Servers
    session_id           NUMBER,                    -- Oracle Session ID des Server-Prozesses
    
    CONSTRAINT fk_lila_rule_ver FOREIGN KEY (rule_version_target) 
        REFERENCES lila_rules_library(rule_version)
);

## Code Optimierung
* Generalisierung der Nachrichten durch eine Methode, die die Elemente header, meta, payload strukturiert und den Zusammenbau vereinfacht


## Server as Singleton
Anstatt DBMS_LOCK, das wieder ein spezielles und riskantes Grant erfordert, per Registry sperren:
Wenn bei Hochfahren ein Eintrag in der Registry mit selbem Pipe-Namen ist und das letzte Update nicht älter als 10 Sekunden ist, ist die Pipe nicht mehr belegt.

