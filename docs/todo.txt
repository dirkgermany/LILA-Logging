## Funktionalität
* Getter für Metriken
* Reconnect für Client und Server

## Server-Gruppen
* Server bei Start einen Gruppen-Namen mitteilen
* Gruppen-Namen in Registry schreiben
* Optional gezieltes Verbinden des Clients mit einer ausgewählten Server-Gruppe `NEW_SESSION`!

## Regeln für Alarmierung
* Eventuell Regel-Tabelle; so kann ein neuer Server, der für eine Gruppe bestimmt ist, die Regeln auslesen

```sql
-- Archiv für die Regel-Definitionen (JSON)
CREATE TABLE lila_rules_library (
    rule_version    NUMBER(10) PRIMARY KEY,
    rule_json       BLOB, -- BLOB oder JSON (ab 21c/23ai), um große Regelwerke zu speichern
    created_at      TIMESTAMP DEFAULT SYSTIMESTAMP,
    description     VARCHAR2(200),
    CONSTRAINT lila_rules_json_chk CHECK (rule_json IS JSON)
);

-- Die Zentrale Server-Registry
CREATE TABLE lila_registry (
    server_name          VARCHAR2(128) PRIMARY KEY, -- Der eindeutige Name (gleichzeitig Pipe-Name)
    server_group         VARCHAR2(128) NOT NULL,    -- Gruppierung für Load-Balancing durch Clients
    is_active            NUMBER(1) DEFAULT 0,       -- 1 = Server läuft, 0 = Inaktiv
    pipe_load            NUMBER(10) DEFAULT 0,      -- Aktueller Füllstand der Pipe (für Client-Wahl)
    rule_version_target  NUMBER(10),                -- Soll-Version (vom Admin gesetzt)
    rule_version_usage   NUMBER(10),                -- Ist-Version (vom Server aktuell genutzt)
    last_heartbeat       TIMESTAMP DEFAULT SYSTIMESTAMP, -- Letzte Aktivität des Servers
    session_id           NUMBER,                    -- Oracle Session ID des Server-Prozesses
    
    CONSTRAINT fk_lila_rule_ver FOREIGN KEY (rule_version_target) 
        REFERENCES lila_rules_library(rule_version)
);

-- Index für den Client-Lookup (Schnellste Suche nach freien Servern)
CREATE INDEX idx_lila_reg_group_load ON lila_registry (server_group, is_active, pipe_load);

```


## Code Optimierung
* Generalisierung der Nachrichten durch eine Methode, die die Elemente header, meta, payload strukturiert und den Zusammenbau vereinfacht

## Purge
* Interval wird aktuell mit keep_days mitgeteilt. Okay. Mit einem speziellen Kommando setSessionImmortal oder Parameter bei NEW_SESSION .immortal = 1 wird das in der Master-Tabelle vermerkt. Bei einem Purge-Lauf werden alle Einträge zur Session nicht gelöscht.
* Das Kommando sollte jederzeit auch für bereits beendete Sessions abgesetzt werden können. Also nicht NEW_SESSION...

## Performance
* dynamische create index sind noch fehlerhaft und werden nicht auf alle Tabellen angewandt
* Indexes grundsätzlich prüfen

## Projekt
* Ordner docs aufräumen, evtl. anderen Ordner für projektorganisatorische Dinge

## Server as Singleton
l_lock_result := DBMS_LOCK.REQUEST(
    lockhandle => l_lock_handle,
    lockmode   => DBMS_LOCK.X_MODE,
    timeout    => 0, -- Sofort fehlschlagen, wenn besetzt
    release_on_commit => FALSE
);

IF l_lock_result != 0 THEN
    raise_application_error(-20001, 'LILA-Server läuft bereits.');
END IF;
